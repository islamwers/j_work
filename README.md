# 📘 Python-гайд по синтаксису и фильтрации для анализа данных (pandas)

Этот гайд — краткий, но достаточный минимум для решения типовых заданий по табличным данным:
- почему функции пишутся со скобками `()`;
- как обращаться к колонкам через `[]`;
- как фильтровать строки и комбинировать условия;
- как работает точка `.` (методы объектов);
- как считать количество строк;
- как обрабатывать дату/время;
- как найти всю строку с максимумом (`idxmax` + `loc`);
- как посчитать IQR (межквартильный размах).

Примеры рассчитаны на таблицу Airbnb-подобных данных (например, `train_B.csv`).

---

## 1) Загрузка данных

```python
import pandas as pd

# CSV:
df = pd.read_csv("train_B.csv")

# Excel:
# df = pd.read_excel("train_B.xlsx")
```

Полезно сразу посмотреть структуру:
```python
df.head()     # первые строки
df.info()     # типы колонок и пропуски
df.columns    # список колонок
```
2) Почему функции пишутся со скобками ()

В Python функция — это действие, которое нужно вызвать, чтобы оно выполнилось.
Скобки () запускают выполнение и передают аргументы.

```python
max([3, 1, 9])   # вернёт 9
len(df)          # вернёт количество строк
print("Hello!")  # выведет текст
```

max без скобок — это просто имя функции (ссылка), она не выполнится.

Даже без аргументов скобки нужны: func().

3) Как обращаться к колонкам через []

df — это таблица (DataFrame).
Доступ к колонке выполняется по имени в квадратных скобках — как к значению по ключу в словаре:

```python
df['price']       # столбец с ценами (Series)
df['room type']   # столбец с типом комнаты
```

Колонка — это объект Series, к нему можно применять методы:
```python
df['price'].max()
df['price'].mean()
df['room type'].unique()
```

4) Фильтрация строк по условию

Базовый шаблон: df[условие].
```python
df[df['price'] > 100]  # строки, где цена > 100
```
Комбинация условий

- & — логическое И

- | — логическое ИЛИ

- ==, >, <, >=, <= — сравнения

Важно: каждое условие берём в скобки ().

Частые паттерны
```python
# Несколько значений:
df[df['borough'].isin(['Brooklyn', 'Queens'])]

# Строковые подстроки (предварительно убедись, что тип — str):
df[df['name'].str.contains('cozy', case=False, na=False)]

# Удалить строки с пропусками в нужных колонках:
clean = df.dropna(subset=['price', 'room type'])
```

5) Точка .: вызов методов объектов

Точка . обращается к методу или атрибуту конкретного объекта.
Примеры полезных методов для колонок (Series):

| Метод                 | Назначение                          |
| --------------------- | ----------------------------------- |
| `.mean()`             | среднее значение                    |
| `.median()`           | медиана                             |
| `.max()`, `.min()`    | максимум / минимум                  |
| `.value_counts()`     | количество уникальных категорий     |
| `.unique()`           | уникальные значения                 |
| `.quantile(q)`        | квантиль (например, `0.25`, `0.75`) |
| `.isna()`, `.notna()` | проверка на пропуски                |

Примеры:

```python
df['price'].mean()
df['room type'].value_counts()
df['price'].quantile(0.25), df['price'].quantile(0.75)
```

6) Подсчёт количества строк: len(...)

```python
len(df)                               # общее число строк
len(df[df['price'] > 200])            # строк с ценой > 200
len(df[(df['borough'] == 'Brooklyn') & (df['price'] <= 100)])
```

7) Работа с датой/временем
Приведение текста к datetime
```python
df['last booking'] = pd.to_datetime(df['last booking'], errors='coerce')

Извлечение компонентов
df['booking_hour'] = df['last booking'].dt.hour
df['booking_date'] = df['last booking'].dt.date
df['booking_weekday'] = df['last booking'].dt.day_name()  # имя дня недели

Фильтр по времени (например, 04:00–11:59)
morning = df[(df['booking_hour'] >= 4) & (df['booking_hour'] <= 11)]
len(morning)
```

💡 Совет: всегда сначала приводите колонку к datetime, иначе .dt не сработает.

8) Найти всю строку с максимумом: idxmax() + loc

Если нужно не просто число-максимум, а вся запись, где он встретился:
```python
idx = df['price'].idxmax()  # индекс строки с max ценой
row = df.loc[idx]           # вся строка
```

Коротко:
```python
df.loc[df['price'].idxmax()]
```

Комбинация с фильтрацией (например, только Shared room 2009 года):
```python
filtered = df[(df['room type'] == 'Shared room') & (df['construction year'] == 2009)]
top_row = filtered.loc[filtered['price'].idxmax()]
```


## 📎 Практические шаблоны (по коду из ноутбука)

### 🔢 Уникальные значения по хостам

Иногда нужно узнать, сколько **уникальных владельцев (host name)** размещают объявления в определённом районе или во всей таблице.  
В `pandas` это делается с помощью комбинации методов `.unique()` и `.nunique()`.

```python
# Пример: количество уникальных хостов по всему датасету
df['host name'].nunique()

# Уникальные имена хостов (списком)
df['host name'].unique()
```

.unique() возвращает массив всех уникальных значений (без повторов).

.nunique() возвращает число уникальных значений (удобно для отчётов).

```# Уникальные хосты только в районе Brooklyn
brooklyn = df[df['borough'] == 'Brooklyn']
n_hosts = brooklyn['host name'].nunique()
print(f'Количество уникальных хостов в Бруклине: {n_hosts}')
```

### 🕒 Работа с датами, неделями, частотой и сортировкой

Работа с датами — одна из ключевых частей анализа данных во временном разрезе.  
Для этого в pandas применяется модуль `datetime` и встроенные атрибуты `.dt`, позволяющие извлекать из даты год, месяц, неделю, день недели и т. д.

---

#### ✅ Преобразование текстовых дат в формат datetime
```python
import pandas as pd

df['last booking'] = pd.to_datetime(df['last booking'], errors='coerce')
```

🧮 Извлечение недель через .dt.isocalendar()

ISO-календарь (международный стандарт) делит год на недели с понедельника по воскресенье.
Метод .dt.isocalendar() возвращает три связанных поля:

year — год по ISO;

week — номер недели (от 1 до 53);

day — день недели (1 = понедельник, 7 = воскресенье).

Пример:

```df['iso'] = df['last booking'].dt.isocalendar()
df['year'] = df['iso'].year
df['week'] = df['iso'].week
df['weekday'] = df['iso'].day
```

📊 Частота встречаемости недель

Чтобы узнать, насколько активно происходили события по неделям, используем value_counts():

```week_freq = df['week'].value_counts().sort_index()
print(week_freq)
```

📤 Результат покажет количество записей на каждую неделю в порядке возрастания номера недели:
```
40     75
41     98
42    125
43     90
```

📅 Сортировка по дате или неделе

Если нужно отсортировать DataFrame по возрастанию даты:
```
df = df.sort_values(by='last booking')
```

По убыванию:

```df = df.sort_values(by='last booking', ascending=False)```

По номеру недели:
```
df = df.sort_values(by='week')
```

💡 Полезные приёмы

Проверить диапазон дат: df['last booking'].min(), df['last booking'].max()

Извлечь год и месяц:
```df['year'] = df['last booking'].dt.year
df['month'] = df['last booking'].dt.month

Извлечь название дня недели:
df['weekday_name'] = df['last booking'].dt.day_name()
```

🔹 ISO-нумерация удобна для анализа временных рядов, особенно если неделя может переходить через границу календарного года (например, 1 января может относиться к 52-й неделе предыдущего года).

### 📊 Boxplot «в одну строчку» — быстрый способ показать распределение

Boxplot (или «ящик с усами») — это компактный способ показать **распределение данных**: медиану, межквартильный размах (IQR), границы нормальных значений и выбросы.  
Он особенно полезен при анализе цен, длительности, рейтингов и любых количественных переменных.

---

#### ✅ Пример: построение boxplot одной командой

```python
import matplotlib.pyplot as plt

df['price'].plot(kind='box', vert=False, grid=True)
plt.title('Boxplot: распределение цен')
plt.show()
```
📎 Аргументы:

kind='box' — тип графика;

vert=False — горизонтальный вид (если убрать, будет вертикальный);

grid=True — сетка для удобства чтения.

⚙️ Перед построением убедись, что колонка числовая:
df['price'] = pd.to_numeric(df['price'], errors='coerce')

🧠 Интерпретация элементов boxplot

Элемент графика	Обозначает
🟥 «ящик»	диапазон от 25-го до 75-го перцентиля (Q1–Q3)
─ линия внутри ящика	медиана (50-й перцентиль)
«усы»	значения в пределах 1.5 * IQR от ящика
точки за пределами усов	выбросы (аномально высокие/низкие значения)

🧩 IQR (interquartile range) = Q3 − Q1
Он показывает степень разброса данных. Большой IQR означает высокую вариативность, маленький — сжатое распределение.

📦 Пример для вычислений и фильтрации выбросов

```q1 = df['price'].quantile(0.25)
q3 = df['price'].quantile(0.75)
iqr = q3 - q1

# отфильтруем выбросы
df_no_outliers = df[(df['price'] >= q1 - 1.5 * iqr) & (df['price'] <= q3 + 1.5 * iqr)]
```

🎨 Несколько boxplot’ов сразу
```df[['price', 'minimum nights', 'availability 365']].plot(kind='box', figsize=(8,5))
plt.title('Boxplot для нескольких переменных')
plt.show()
```

Boxplot — это быстрая визуальная проверка «здоровья» данных.
Он показывает, где сосредоточено большинство значений, насколько данные симметричны и есть ли выбросы, требующие внимания.





